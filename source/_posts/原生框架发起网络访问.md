---
title: 原生框架发起网络访问
date: 2016-04-21 19:40:10
tags: iOS
categories: iOS基础

---

#### 1.常用访问方法 

- GET 检索一个连接的请求或者从服务端获取HTTP术语中的一个实体。GET一般允许但是不包含请求体。有些网络缓存会缓存请求的回答。一般情况下，GET不会引起服务端数据改变。（支持发送少量的数据8KB，大量数据使用POST） 
- POST从客户端更新一个实体的数据。一般POST请求通常有请求信息放在body里。POST请求是非量级更新的（non-idempotent），每次更新都应该与第一次有所不同。 
- HEAD 用于检索请求回应的元数据的大小。通常用来计算服务端数据的返回数据百分比。 
- DELETE 用于移除基于客户端请求体里提供的URI指向的资源。在REST中使用频繁些。 

#### 2.使用`NSURL` `NSMutableURLRequest` `NSURLRequest` `NSURLConnection`发起请求。 

##### 2.1NSURLConnection发起访问 

- 同步访问  
  sendSynchronousRequest: returningResponse: error: 
- 异步访问  
  sendAsynchronousRequest: queue: completionHandler: 

  ```objc
  NSURL *url = [NSURL URLWithString:urlString]; 
  NSMutableURLRequest *request = [[NSMutableURLRequest alloc]initWithURL:url]; 
  [request addValue:@"154085236" forHTTPHeaderField:@"userId"]; 
   [request addValue:@"encrypt xeyTUA5o8vfObEDB+gtzRHUdjbY9oaPfyj4Z8uA9dIxRayXrkzCO4a1kPx0srtKE5pvSfv4VoH9hp2YfV5HBsQ==" forHTTPHeaderField:@"Authorization"]; 
   NSHTTPURLResponse *response; 
   NSError *error; 
   //**发情同步请求 
   NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:&response error:&error]; 
   //**序列化解析 
   id responseDic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:&error]; 
  NSLog(@"%@",responseDic); 
  //**新建一个队列 
  NSOperationQueue *queue = [[NSOperationQueue alloc]init]; 
  //**异步发起请求 
  [NSURLConnection sendAsynchronousRequest:request queue:queue completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) { 
   NSError *error; 
   id responseDic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:&error]; 
   NSLog(@"%@",responseDic); 
  }]; 
  ```

##### 2.2.如果需要更多的访问状态反馈可以实现代理方法 

- 实现NSURLConnectionDelegate 
``` objc
 // 请求失败回调
 - (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error; 

// 是否使用本地凭证
- (BOOL)connectionShouldUseCredentialStorage:(NSURLConnection *)connection; 

//将要发起鉴权
 - (void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge; 

- (BOOL)connection:(NSURLConnection *)connection canAuthenticateAgainstProtectionSpace:(NSURLProtectionSpace *)protectionSpace; 

- (void)connection:(NSURLConnection *)connection didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge; 

- (void)connection:(NSURLConnection *)connection didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge; 
 
```

- 发起请求 

 ```
NSURLConnection connection = [[NSURLConnection alloc] initWithRequest:request 

delegate:self startImmediately:NO]; 

[connection scheduleInRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; [connection start]; 
 ```



#### 3.使用NSURLSession``NSURLSessionDataTask``NSURLSessionConfiguration进行网络访问进度显示 

##### 3.1`NSURLSession` `NSURLSessionDataTask` `NSURLSessionConfiguration`三者的关系 

- 这三个东西是什么？  
  可以简单的理解为发起访问的三个组. 

- NSURLSession代替了NSURLConnection，是发起Http请求的前期准备，底层怎么实现就先忽略吧。每一个网络会话（NSRURLSession）需要一个配置（NSSessionConfiguration）。每个session可以进行多个任务（NSURLSessionTask）; 

- NSSessionConfiguration配置里提供了配置请求的一些属性：缓存策略@property NSURLRequestCachePolicy requestCachePolicy;,超时设置:@property NSTimeInterval timeoutIntervalForRequest;,cookies信息等。 

- SURLSessionDataTask是NSURLSessionTask的子类。NSURLSessionTask常用的子类  

- NSURLSessionDataTask：用来请求资源，然后服务器返回数据，再内存中存储为NSData格式。default,ephemeral,sharedSession支持data task。backgroundsession不支持。 

- NSURLSessionUploadTask:和DataTask类似，只不过在请求的时候提供了request body。并且background Session支持 upload task。 

- NSURLSessionDownloadTask:下载内容到硬盘上，所有类型的Session都支持。 

- 使用: 

- 初始化一个Session 
```
- NSURLSessionConfiguration *config = [NSURLSessionConfiguration ephemeralSessionConfiguration]; 

_session = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:[NSOperationQueue mainQueue]];

```

- 创建一个task 
  

```
_sessionDataTask = [self.session dataTaskWithURL:self.url];
```

- 开始一个任务 
  

```
[self.sessionDataTask resume]; 
```

